// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.20.3
// source: types/account.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Digest, MerklePath } from "./primitives";

export const protobufPackage = "account";

/**
 * Uniquely identifies a specific account.
 *
 * A Miden account ID is a 120-bit value derived from the commitments to account code and storage,
 * and a random user-provided seed.
 */
export interface AccountId {
  /**
   * 15 bytes (120 bits) encoded using [winter_utils::Serializable] implementation for
   * [miden_objects::account::account_id::AccountId].
   */
  id: Uint8Array;
}

/** The state of an account at a specific block height. */
export interface AccountSummary {
  /** The account ID. */
  accountId:
    | AccountId
    | undefined;
  /** The current account commitment or zero if the account does not exist. */
  accountCommitment:
    | Digest
    | undefined;
  /** Block number at which the summary was made. */
  blockNum: number;
}

/** An account details. */
export interface AccountDetails {
  /** Account summary. */
  summary:
    | AccountSummary
    | undefined;
  /**
   * Account details encoded using [winter_utils::Serializable] implementation for
   * [miden_objects::account::Account].
   */
  details?: Uint8Array | undefined;
}

/** An account header. */
export interface AccountHeader {
  /** Vault root hash. */
  vaultRoot:
    | Digest
    | undefined;
  /** Storage root hash. */
  storageCommitment:
    | Digest
    | undefined;
  /** Code root hash. */
  codeCommitment:
    | Digest
    | undefined;
  /** Account nonce. */
  nonce: number;
}

/** An account witness. */
export interface AccountWitness {
  /** Account ID for which this proof is requested. */
  accountId:
    | AccountId
    | undefined;
  /**
   * The account ID within the proof, which may be different from the above account ID.
   * This can happen when the requested account ID's prefix matches the prefix of an existing
   * account ID in the tree. Then the witness will prove inclusion of this witness ID in the tree.
   */
  witnessId:
    | AccountId
    | undefined;
  /** The state commitment whose inclusion the witness proves. */
  commitment:
    | Digest
    | undefined;
  /** The merkle path of the state commitment in the account tree. */
  path: MerklePath | undefined;
}

function createBaseAccountId(): AccountId {
  return { id: new Uint8Array(0) };
}

export const AccountId: MessageFns<AccountId> = {
  encode(message: AccountId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountId {
    return { id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0) };
  },

  toJSON(message: AccountId): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountId>, I>>(base?: I): AccountId {
    return AccountId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountId>, I>>(object: I): AccountId {
    const message = createBaseAccountId();
    message.id = object.id ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAccountSummary(): AccountSummary {
  return { accountId: undefined, accountCommitment: undefined, blockNum: 0 };
}

export const AccountSummary: MessageFns<AccountSummary> = {
  encode(message: AccountSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== undefined) {
      AccountId.encode(message.accountId, writer.uint32(10).fork()).join();
    }
    if (message.accountCommitment !== undefined) {
      Digest.encode(message.accountCommitment, writer.uint32(18).fork()).join();
    }
    if (message.blockNum !== 0) {
      writer.uint32(24).uint32(message.blockNum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = AccountId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountCommitment = Digest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.blockNum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountSummary {
    return {
      accountId: isSet(object.accountId) ? AccountId.fromJSON(object.accountId) : undefined,
      accountCommitment: isSet(object.accountCommitment) ? Digest.fromJSON(object.accountCommitment) : undefined,
      blockNum: isSet(object.blockNum) ? globalThis.Number(object.blockNum) : 0,
    };
  },

  toJSON(message: AccountSummary): unknown {
    const obj: any = {};
    if (message.accountId !== undefined) {
      obj.accountId = AccountId.toJSON(message.accountId);
    }
    if (message.accountCommitment !== undefined) {
      obj.accountCommitment = Digest.toJSON(message.accountCommitment);
    }
    if (message.blockNum !== 0) {
      obj.blockNum = Math.round(message.blockNum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountSummary>, I>>(base?: I): AccountSummary {
    return AccountSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountSummary>, I>>(object: I): AccountSummary {
    const message = createBaseAccountSummary();
    message.accountId = (object.accountId !== undefined && object.accountId !== null)
      ? AccountId.fromPartial(object.accountId)
      : undefined;
    message.accountCommitment = (object.accountCommitment !== undefined && object.accountCommitment !== null)
      ? Digest.fromPartial(object.accountCommitment)
      : undefined;
    message.blockNum = object.blockNum ?? 0;
    return message;
  },
};

function createBaseAccountDetails(): AccountDetails {
  return { summary: undefined, details: undefined };
}

export const AccountDetails: MessageFns<AccountDetails> = {
  encode(message: AccountDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.summary !== undefined) {
      AccountSummary.encode(message.summary, writer.uint32(10).fork()).join();
    }
    if (message.details !== undefined) {
      writer.uint32(18).bytes(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.summary = AccountSummary.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.details = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountDetails {
    return {
      summary: isSet(object.summary) ? AccountSummary.fromJSON(object.summary) : undefined,
      details: isSet(object.details) ? bytesFromBase64(object.details) : undefined,
    };
  },

  toJSON(message: AccountDetails): unknown {
    const obj: any = {};
    if (message.summary !== undefined) {
      obj.summary = AccountSummary.toJSON(message.summary);
    }
    if (message.details !== undefined) {
      obj.details = base64FromBytes(message.details);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountDetails>, I>>(base?: I): AccountDetails {
    return AccountDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountDetails>, I>>(object: I): AccountDetails {
    const message = createBaseAccountDetails();
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? AccountSummary.fromPartial(object.summary)
      : undefined;
    message.details = object.details ?? undefined;
    return message;
  },
};

function createBaseAccountHeader(): AccountHeader {
  return { vaultRoot: undefined, storageCommitment: undefined, codeCommitment: undefined, nonce: 0 };
}

export const AccountHeader: MessageFns<AccountHeader> = {
  encode(message: AccountHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vaultRoot !== undefined) {
      Digest.encode(message.vaultRoot, writer.uint32(10).fork()).join();
    }
    if (message.storageCommitment !== undefined) {
      Digest.encode(message.storageCommitment, writer.uint32(18).fork()).join();
    }
    if (message.codeCommitment !== undefined) {
      Digest.encode(message.codeCommitment, writer.uint32(26).fork()).join();
    }
    if (message.nonce !== 0) {
      writer.uint32(32).uint64(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vaultRoot = Digest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.storageCommitment = Digest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.codeCommitment = Digest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.nonce = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountHeader {
    return {
      vaultRoot: isSet(object.vaultRoot) ? Digest.fromJSON(object.vaultRoot) : undefined,
      storageCommitment: isSet(object.storageCommitment) ? Digest.fromJSON(object.storageCommitment) : undefined,
      codeCommitment: isSet(object.codeCommitment) ? Digest.fromJSON(object.codeCommitment) : undefined,
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
    };
  },

  toJSON(message: AccountHeader): unknown {
    const obj: any = {};
    if (message.vaultRoot !== undefined) {
      obj.vaultRoot = Digest.toJSON(message.vaultRoot);
    }
    if (message.storageCommitment !== undefined) {
      obj.storageCommitment = Digest.toJSON(message.storageCommitment);
    }
    if (message.codeCommitment !== undefined) {
      obj.codeCommitment = Digest.toJSON(message.codeCommitment);
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountHeader>, I>>(base?: I): AccountHeader {
    return AccountHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountHeader>, I>>(object: I): AccountHeader {
    const message = createBaseAccountHeader();
    message.vaultRoot = (object.vaultRoot !== undefined && object.vaultRoot !== null)
      ? Digest.fromPartial(object.vaultRoot)
      : undefined;
    message.storageCommitment = (object.storageCommitment !== undefined && object.storageCommitment !== null)
      ? Digest.fromPartial(object.storageCommitment)
      : undefined;
    message.codeCommitment = (object.codeCommitment !== undefined && object.codeCommitment !== null)
      ? Digest.fromPartial(object.codeCommitment)
      : undefined;
    message.nonce = object.nonce ?? 0;
    return message;
  },
};

function createBaseAccountWitness(): AccountWitness {
  return { accountId: undefined, witnessId: undefined, commitment: undefined, path: undefined };
}

export const AccountWitness: MessageFns<AccountWitness> = {
  encode(message: AccountWitness, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== undefined) {
      AccountId.encode(message.accountId, writer.uint32(10).fork()).join();
    }
    if (message.witnessId !== undefined) {
      AccountId.encode(message.witnessId, writer.uint32(18).fork()).join();
    }
    if (message.commitment !== undefined) {
      Digest.encode(message.commitment, writer.uint32(26).fork()).join();
    }
    if (message.path !== undefined) {
      MerklePath.encode(message.path, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountWitness {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountWitness();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = AccountId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.witnessId = AccountId.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commitment = Digest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.path = MerklePath.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountWitness {
    return {
      accountId: isSet(object.accountId) ? AccountId.fromJSON(object.accountId) : undefined,
      witnessId: isSet(object.witnessId) ? AccountId.fromJSON(object.witnessId) : undefined,
      commitment: isSet(object.commitment) ? Digest.fromJSON(object.commitment) : undefined,
      path: isSet(object.path) ? MerklePath.fromJSON(object.path) : undefined,
    };
  },

  toJSON(message: AccountWitness): unknown {
    const obj: any = {};
    if (message.accountId !== undefined) {
      obj.accountId = AccountId.toJSON(message.accountId);
    }
    if (message.witnessId !== undefined) {
      obj.witnessId = AccountId.toJSON(message.witnessId);
    }
    if (message.commitment !== undefined) {
      obj.commitment = Digest.toJSON(message.commitment);
    }
    if (message.path !== undefined) {
      obj.path = MerklePath.toJSON(message.path);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountWitness>, I>>(base?: I): AccountWitness {
    return AccountWitness.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountWitness>, I>>(object: I): AccountWitness {
    const message = createBaseAccountWitness();
    message.accountId = (object.accountId !== undefined && object.accountId !== null)
      ? AccountId.fromPartial(object.accountId)
      : undefined;
    message.witnessId = (object.witnessId !== undefined && object.witnessId !== null)
      ? AccountId.fromPartial(object.witnessId)
      : undefined;
    message.commitment = (object.commitment !== undefined && object.commitment !== null)
      ? Digest.fromPartial(object.commitment)
      : undefined;
    message.path = (object.path !== undefined && object.path !== null)
      ? MerklePath.fromPartial(object.path)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
