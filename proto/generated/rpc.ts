// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.20.3
// source: rpc.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  BlockProducerStatus,
  SubmitProvenTransactionResponse,
} from "./block_producer";
import { Empty } from "./google/protobuf/empty";
import {
  AccountProofs,
  AccountProofsRequest,
  AccountStateDelta,
  AccountStateDeltaRequest,
  CheckNullifiersByPrefixRequest,
  CheckNullifiersByPrefixResponse,
  CheckNullifiersResponse,
  NullifierList,
  StoreStatus,
  SyncNotesRequest,
  SyncNotesResponse,
  SyncStateRequest,
  SyncStateResponse,
} from "./store/rpc";
import {
  BlockHeaderByNumberRequest,
  BlockHeaderByNumberResponse,
} from "./store/shared";
import { AccountDetails, AccountId } from "./types/account";
import { BlockNumber, MaybeBlock } from "./types/blockchain";
import { CommittedNoteList, NoteIdList } from "./types/note";
import { ProvenTransaction } from "./types/transaction";

export const protobufPackage = "rpc";

/** Specification of the user facing gRPC API. */

/** Represents the status of the node. */
export interface RpcStatus {
  /** The rpc component's running version. */
  version: string;
  /** The store status. */
  store: StoreStatus | undefined;
  /** The block producer status. */
  blockProducer: BlockProducerStatus | undefined;
}

function createBaseRpcStatus(): RpcStatus {
  return { version: "", store: undefined, blockProducer: undefined };
}

export const RpcStatus: MessageFns<RpcStatus> = {
  encode(
    message: RpcStatus,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.store !== undefined) {
      StoreStatus.encode(message.store, writer.uint32(26).fork()).join();
    }
    if (message.blockProducer !== undefined) {
      BlockProducerStatus.encode(
        message.blockProducer,
        writer.uint32(34).fork()
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcStatus {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.store = StoreStatus.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.blockProducer = BlockProducerStatus.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RpcStatus {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      store: isSet(object.store)
        ? StoreStatus.fromJSON(object.store)
        : undefined,
      blockProducer: isSet(object.blockProducer)
        ? BlockProducerStatus.fromJSON(object.blockProducer)
        : undefined,
    };
  },

  toJSON(message: RpcStatus): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.store !== undefined) {
      obj.store = StoreStatus.toJSON(message.store);
    }
    if (message.blockProducer !== undefined) {
      obj.blockProducer = BlockProducerStatus.toJSON(message.blockProducer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RpcStatus>, I>>(base?: I): RpcStatus {
    return RpcStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RpcStatus>, I>>(
    object: I
  ): RpcStatus {
    const message = createBaseRpcStatus();
    message.version = object.version ?? "";
    message.store =
      object.store !== undefined && object.store !== null
        ? StoreStatus.fromPartial(object.store)
        : undefined;
    message.blockProducer =
      object.blockProducer !== undefined && object.blockProducer !== null
        ? BlockProducerStatus.fromPartial(object.blockProducer)
        : undefined;
    return message;
  },
};

/** RPC API for the RPC component */
export interface Api {
  /** Returns the status info of the node. */
  Status(request: Empty): Promise<RpcStatus>;
  /** Returns a nullifier proof for each of the requested nullifiers. */
  CheckNullifiers(request: NullifierList): Promise<CheckNullifiersResponse>;
  /**
   * Returns a list of nullifiers that match the specified prefixes and are recorded in the node.
   *
   * Note that only 16-bit prefixes are supported at this time.
   */
  CheckNullifiersByPrefix(
    request: CheckNullifiersByPrefixRequest
  ): Promise<CheckNullifiersByPrefixResponse>;
  /** Returns the latest state of an account with the specified ID. */
  GetAccountDetails(request: AccountId): Promise<AccountDetails>;
  /** Returns the latest state proofs of the specified accounts. */
  GetAccountProofs(request: AccountProofsRequest): Promise<AccountProofs>;
  /**
   * Returns delta of the account states in the range from `from_block_num` (exclusive) to
   * `to_block_num` (inclusive).
   */
  GetAccountStateDelta(
    request: AccountStateDeltaRequest
  ): Promise<AccountStateDelta>;
  /** Returns raw block data for the specified block number. */
  GetBlockByNumber(request: BlockNumber): Promise<MaybeBlock>;
  /**
   * Retrieves block header by given block number. Optionally, it also returns the MMR path
   * and current chain length to authenticate the block's inclusion.
   */
  GetBlockHeaderByNumber(
    request: BlockHeaderByNumberRequest
  ): Promise<BlockHeaderByNumberResponse>;
  /** Returns a list of notes matching the provided note IDs. */
  GetNotesById(request: NoteIdList): Promise<CommittedNoteList>;
  /** Submits proven transaction to the Miden network. */
  SubmitProvenTransaction(
    request: ProvenTransaction
  ): Promise<SubmitProvenTransactionResponse>;
  /**
   * Returns info which can be used by the client to sync up to the tip of chain for the notes they are interested in.
   *
   * Client specifies the `note_tags` they are interested in, and the block height from which to search for new for
   * matching notes for. The request will then return the next block containing any note matching the provided tags.
   *
   * The response includes each note's metadata and inclusion proof.
   *
   * A basic note sync can be implemented by repeatedly requesting the previous response's block until reaching the
   * tip of the chain.
   */
  SyncNotes(request: SyncNotesRequest): Promise<SyncNotesResponse>;
  /**
   * Returns info which can be used by the client to sync up to the latest state of the chain
   * for the objects (accounts and notes) the client is interested in.
   *
   * This request returns the next block containing requested data. It also returns `chain_tip`
   * which is the latest block number in the chain. Client is expected to repeat these requests
   * in a loop until `response.block_header.block_num == response.chain_tip`, at which point
   * the client is fully synchronized with the chain.
   *
   * Each update response also contains info about new notes, accounts etc. created. It also returns
   * Chain MMR delta that can be used to update the state of Chain MMR. This includes both chain
   * MMR peaks and chain MMR nodes.
   *
   * For preserving some degree of privacy, note tags contain only high
   * part of hashes. Thus, returned data contains excessive notes, client can make
   * additional filtering of that data on its side.
   */
  SyncState(request: SyncStateRequest): Promise<SyncStateResponse>;
}

export const ApiServiceName = "rpc.Api";
export class ApiClientImpl implements Api {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ApiServiceName;
    this.rpc = rpc;
    this.Status = this.Status.bind(this);
    this.CheckNullifiers = this.CheckNullifiers.bind(this);
    this.CheckNullifiersByPrefix = this.CheckNullifiersByPrefix.bind(this);
    this.GetAccountDetails = this.GetAccountDetails.bind(this);
    this.GetAccountProofs = this.GetAccountProofs.bind(this);
    this.GetAccountStateDelta = this.GetAccountStateDelta.bind(this);
    this.GetBlockByNumber = this.GetBlockByNumber.bind(this);
    this.GetBlockHeaderByNumber = this.GetBlockHeaderByNumber.bind(this);
    this.GetNotesById = this.GetNotesById.bind(this);
    this.SubmitProvenTransaction = this.SubmitProvenTransaction.bind(this);
    this.SyncNotes = this.SyncNotes.bind(this);
    this.SyncState = this.SyncState.bind(this);
  }
  Status(request: Empty): Promise<RpcStatus> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "Status", data);
    return promise.then((data) => RpcStatus.decode(new BinaryReader(data)));
  }

  CheckNullifiers(request: NullifierList): Promise<CheckNullifiersResponse> {
    const data = NullifierList.encode(request).finish();
    const promise = this.rpc.request(this.service, "CheckNullifiers", data);
    return promise.then((data) =>
      CheckNullifiersResponse.decode(new BinaryReader(data))
    );
  }

  CheckNullifiersByPrefix(
    request: CheckNullifiersByPrefixRequest
  ): Promise<CheckNullifiersByPrefixResponse> {
    const data = CheckNullifiersByPrefixRequest.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "CheckNullifiersByPrefix",
      data
    );
    return promise.then((data) =>
      CheckNullifiersByPrefixResponse.decode(new BinaryReader(data))
    );
  }

  GetAccountDetails(request: AccountId): Promise<AccountDetails> {
    const data = AccountId.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAccountDetails", data);
    return promise.then((data) =>
      AccountDetails.decode(new BinaryReader(data))
    );
  }

  GetAccountProofs(request: AccountProofsRequest): Promise<AccountProofs> {
    const data = AccountProofsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAccountProofs", data);
    return promise.then((data) => AccountProofs.decode(new BinaryReader(data)));
  }

  GetAccountStateDelta(
    request: AccountStateDeltaRequest
  ): Promise<AccountStateDelta> {
    const data = AccountStateDeltaRequest.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "GetAccountStateDelta",
      data
    );
    return promise.then((data) =>
      AccountStateDelta.decode(new BinaryReader(data))
    );
  }

  GetBlockByNumber(request: BlockNumber): Promise<MaybeBlock> {
    const data = BlockNumber.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBlockByNumber", data);
    return promise.then((data) => MaybeBlock.decode(new BinaryReader(data)));
  }

  GetBlockHeaderByNumber(
    request: BlockHeaderByNumberRequest
  ): Promise<BlockHeaderByNumberResponse> {
    const data = BlockHeaderByNumberRequest.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "GetBlockHeaderByNumber",
      data
    );
    return promise.then((data) =>
      BlockHeaderByNumberResponse.decode(new BinaryReader(data))
    );
  }

  GetNotesById(request: NoteIdList): Promise<CommittedNoteList> {
    const data = NoteIdList.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNotesById", data);
    return promise.then((data) =>
      CommittedNoteList.decode(new BinaryReader(data))
    );
  }

  SubmitProvenTransaction(
    request: ProvenTransaction
  ): Promise<SubmitProvenTransactionResponse> {
    const data = ProvenTransaction.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "SubmitProvenTransaction",
      data
    );
    return promise.then((data) =>
      SubmitProvenTransactionResponse.decode(new BinaryReader(data))
    );
  }

  SyncNotes(request: SyncNotesRequest): Promise<SyncNotesResponse> {
    const data = SyncNotesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SyncNotes", data);
    return promise.then((data) =>
      SyncNotesResponse.decode(new BinaryReader(data))
    );
  }

  SyncState(request: SyncStateRequest): Promise<SyncStateResponse> {
    const data = SyncStateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SyncState", data);
    return promise.then((data) =>
      SyncStateResponse.decode(new BinaryReader(data))
    );
  }
}

export interface Rpc {
  request(
    service: string,
    method: string,
    data: Uint8Array
  ): Promise<Uint8Array>;
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
