// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.20.3
// source: store/rpc.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Empty } from "../google/protobuf/empty";
import {
  AccountDetails,
  AccountHeader,
  AccountId,
  AccountSummary,
  AccountWitness,
} from "../types/account";
import { BlockHeader, BlockNumber, MaybeBlock } from "../types/blockchain";
import { CommittedNoteList, NoteIdList, NoteSyncRecord } from "../types/note";
import { Digest, MerklePath, MmrDelta, SmtOpening } from "../types/primitives";
import { TransactionSummary } from "../types/transaction";
import {
  BlockHeaderByNumberRequest,
  BlockHeaderByNumberResponse,
} from "./shared";

export const protobufPackage = "rpc_store";

/**
 * Specification of the store RPC.
 *
 * This provided access to the blockchain data to the other nodes.
 */

/** Represents the status of the store. */
export interface StoreStatus {
  /** The store's running version. */
  version: string;
  /** The store's status. */
  status: string;
  /** Number of the latest block in the chain. */
  chainTip: number;
}

/** Returns the latest state proofs of the specified accounts. */
export interface AccountProofsRequest {
  /** A list of account requests, including map keys + values. */
  accountRequests: AccountProofsRequest_AccountRequest[];
  /**
   * Optional flag to include account headers and account code in the response. If false, storage
   * requests are also ignored. False by default.
   */
  includeHeaders?: boolean | undefined;
  /**
   * Account code commitments corresponding to the last-known `AccountCode` for requested
   * accounts. Responses will include only the ones that are not known to the caller.
   * These are not associated with a specific account but rather, they will be matched against
   * all requested accounts.
   */
  codeCommitments: Digest[];
}

/**
 * Represents per-account requests where each account ID has its own list of
 * (storage_slot_index, map_keys) pairs.
 */
export interface AccountProofsRequest_AccountRequest {
  /** The account ID for this request. */
  accountId: AccountId | undefined;
  /** List of storage requests for this account. */
  storageRequests: AccountProofsRequest_AccountRequest_StorageRequest[];
}

/** Represents a storage slot index and the associated map keys. */
export interface AccountProofsRequest_AccountRequest_StorageRequest {
  /** Storage slot index ([0..255]) */
  storageSlotIndex: number;
  /** A list of map keys (Digests) associated with this storage slot. */
  mapKeys: Digest[];
}

/** Represents the result of getting account proofs. */
export interface AccountProofs {
  /** Block number at which the state of the accounts is returned. */
  blockNum: number;
  /** List of account state infos for the requested account keys. */
  accountProofs: AccountProofs_AccountProof[];
}

/** A single account proof returned as a response to `GetAccountProofs`. */
export interface AccountProofs_AccountProof {
  /** The account witness for the current state commitment of one account ID. */
  witness: AccountWitness | undefined;
  /** State header for public accounts. Filled only if `include_headers` flag is set to `true`. */
  stateHeader?: AccountProofs_AccountProof_AccountStateHeader | undefined;
}

/** State header for public accounts. */
export interface AccountProofs_AccountProof_AccountStateHeader {
  /** Account header. */
  header: AccountHeader | undefined;
  /** Values of all account storage slots (max 255). */
  storageHeader: Uint8Array;
  /**
   * Account code, returned only when none of the request's code commitments match
   * the current one.
   */
  accountCode?: Uint8Array | undefined;
  /** Storage slots information for this account */
  storageMaps: AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof[];
}

/** Represents a single storage slot with the requested keys and their respective values. */
export interface AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof {
  /** The storage slot index ([0..255]). */
  storageSlot: number;
  /** Merkle proof of the map value */
  smtProof: Uint8Array;
}

/**
 * Returns delta of the account states in the range from `from_block_num` (exclusive) to
 * `to_block_num` (inclusive).
 */
export interface AccountStateDeltaRequest {
  /** ID of the account for which the delta is requested. */
  accountId: AccountId | undefined;
  /** Block number from which the delta is requested (exclusive). */
  fromBlockNum: number;
  /** Block number up to which the delta is requested (inclusive). */
  toBlockNum: number;
}

/** Represents the result of getting account state delta. */
export interface AccountStateDelta {
  /**
   * The calculated account delta encoded using [winter_utils::Serializable] implementation
   * for [miden_objects::account::delta::AccountDelta].
   */
  delta?: Uint8Array | undefined;
}

/** Returns a list of nullifiers that match the specified prefixes and are recorded in the node. */
export interface CheckNullifiersByPrefixRequest {
  /** Number of bits used for nullifier prefix. Currently the only supported value is 16. */
  prefixLen: number;
  /**
   * List of nullifiers to check. Each nullifier is specified by its prefix with length equal
   * to `prefix_len`.
   */
  nullifiers: number[];
  /** Block number from which the nullifiers are requested (inclusive). */
  blockNum: number;
}

/** Represents the result of checking nullifiers by prefix. */
export interface CheckNullifiersByPrefixResponse {
  /** List of nullifiers matching the prefixes specified in the request. */
  nullifiers: CheckNullifiersByPrefixResponse_NullifierUpdate[];
}

/** Represents a single nullifier update. */
export interface CheckNullifiersByPrefixResponse_NullifierUpdate {
  /** Nullifier ID. */
  nullifier: Digest | undefined;
  /** Block number. */
  blockNum: number;
}

/** List of nullifiers to return proofs for. */
export interface NullifierList {
  /** List of nullifiers to return proofs for. */
  nullifiers: Digest[];
}

/** Represents the result of checking nullifiers. */
export interface CheckNullifiersResponse {
  /** Each requested nullifier has its corresponding nullifier proof at the same position. */
  proofs: SmtOpening[];
}

/**
 * State synchronization request.
 *
 * Specifies state updates the client is interested in. The server will return the first block which
 * contains a note matching `note_tags` or the chain tip. And the corresponding updates to
 * `account_ids` for that block range.
 */
export interface SyncStateRequest {
  /**
   * Last block known by the client. The response will contain data starting from the next block,
   * until the first block which contains a note of matching the requested tag, or the chain tip
   * if there are no notes.
   */
  blockNum: number;
  /**
   * Accounts' commitment to include in the response.
   *
   * An account commitment will be included if-and-only-if it is the latest update. Meaning it is
   * possible there was an update to the account for the given range, but if it is not the latest,
   * it won't be included in the response.
   */
  accountIds: AccountId[];
  /** Specifies the tags which the client is interested in. */
  noteTags: number[];
}

/** Represents the result of syncing state request. */
export interface SyncStateResponse {
  /** Number of the latest block in the chain. */
  chainTip: number;
  /** Block header of the block with the first note matching the specified criteria. */
  blockHeader: BlockHeader | undefined;
  /** Data needed to update the partial MMR from `request.block_num + 1` to `response.block_header.block_num`. */
  mmrDelta: MmrDelta | undefined;
  /** List of account commitments updated after `request.block_num + 1` but not after `response.block_header.block_num`. */
  accounts: AccountSummary[];
  /**
   * List of transactions executed against requested accounts between `request.block_num + 1` and
   * `response.block_header.block_num`.
   */
  transactions: TransactionSummary[];
  /** List of all notes together with the Merkle paths from `response.block_header.note_root`. */
  notes: NoteSyncRecord[];
}

/**
 * Note synchronization request.
 *
 * Specifies note tags that client is interested in. The server will return the first block which
 * contains a note matching `note_tags` or the chain tip.
 */
export interface SyncNotesRequest {
  /**
   * Last block known by the client. The response will contain data starting from the next block,
   * until the first block which contains a note of matching the requested tag.
   */
  blockNum: number;
  /** Specifies the tags which the client is interested in. */
  noteTags: number[];
}

/** Represents the result of syncing notes request. */
export interface SyncNotesResponse {
  /** Number of the latest block in the chain. */
  chainTip: number;
  /** Block header of the block with the first note matching the specified criteria. */
  blockHeader: BlockHeader | undefined;
  /**
   * Merkle path to verify the block's inclusion in the MMR at the returned `chain_tip`.
   *
   * An MMR proof can be constructed for the leaf of index `block_header.block_num` of
   * an MMR of forest `chain_tip` with this path.
   */
  mmrPath: MerklePath | undefined;
  /** List of all notes together with the Merkle paths from `response.block_header.note_root`. */
  notes: NoteSyncRecord[];
}

function createBaseStoreStatus(): StoreStatus {
  return { version: "", status: "", chainTip: 0 };
}

export const StoreStatus: MessageFns<StoreStatus> = {
  encode(
    message: StoreStatus,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.chainTip !== 0) {
      writer.uint32(29).fixed32(message.chainTip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreStatus {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.chainTip = reader.fixed32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StoreStatus {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      chainTip: isSet(object.chainTip) ? globalThis.Number(object.chainTip) : 0,
    };
  },

  toJSON(message: StoreStatus): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.chainTip !== 0) {
      obj.chainTip = Math.round(message.chainTip);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StoreStatus>, I>>(base?: I): StoreStatus {
    return StoreStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StoreStatus>, I>>(
    object: I
  ): StoreStatus {
    const message = createBaseStoreStatus();
    message.version = object.version ?? "";
    message.status = object.status ?? "";
    message.chainTip = object.chainTip ?? 0;
    return message;
  },
};

function createBaseAccountProofsRequest(): AccountProofsRequest {
  return {
    accountRequests: [],
    includeHeaders: undefined,
    codeCommitments: [],
  };
}

export const AccountProofsRequest: MessageFns<AccountProofsRequest> = {
  encode(
    message: AccountProofsRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.accountRequests) {
      AccountProofsRequest_AccountRequest.encode(
        v!,
        writer.uint32(10).fork()
      ).join();
    }
    if (message.includeHeaders !== undefined) {
      writer.uint32(16).bool(message.includeHeaders);
    }
    for (const v of message.codeCommitments) {
      Digest.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): AccountProofsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountProofsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountRequests.push(
            AccountProofsRequest_AccountRequest.decode(reader, reader.uint32())
          );
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.includeHeaders = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.codeCommitments.push(Digest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountProofsRequest {
    return {
      accountRequests: globalThis.Array.isArray(object?.accountRequests)
        ? object.accountRequests.map((e: any) =>
            AccountProofsRequest_AccountRequest.fromJSON(e)
          )
        : [],
      includeHeaders: isSet(object.includeHeaders)
        ? globalThis.Boolean(object.includeHeaders)
        : undefined,
      codeCommitments: globalThis.Array.isArray(object?.codeCommitments)
        ? object.codeCommitments.map((e: any) => Digest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AccountProofsRequest): unknown {
    const obj: any = {};
    if (message.accountRequests?.length) {
      obj.accountRequests = message.accountRequests.map((e) =>
        AccountProofsRequest_AccountRequest.toJSON(e)
      );
    }
    if (message.includeHeaders !== undefined) {
      obj.includeHeaders = message.includeHeaders;
    }
    if (message.codeCommitments?.length) {
      obj.codeCommitments = message.codeCommitments.map((e) =>
        Digest.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountProofsRequest>, I>>(
    base?: I
  ): AccountProofsRequest {
    return AccountProofsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountProofsRequest>, I>>(
    object: I
  ): AccountProofsRequest {
    const message = createBaseAccountProofsRequest();
    message.accountRequests =
      object.accountRequests?.map((e) =>
        AccountProofsRequest_AccountRequest.fromPartial(e)
      ) || [];
    message.includeHeaders = object.includeHeaders ?? undefined;
    message.codeCommitments =
      object.codeCommitments?.map((e) => Digest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAccountProofsRequest_AccountRequest(): AccountProofsRequest_AccountRequest {
  return { accountId: undefined, storageRequests: [] };
}

export const AccountProofsRequest_AccountRequest: MessageFns<AccountProofsRequest_AccountRequest> =
  {
    encode(
      message: AccountProofsRequest_AccountRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.accountId !== undefined) {
        AccountId.encode(message.accountId, writer.uint32(10).fork()).join();
      }
      for (const v of message.storageRequests) {
        AccountProofsRequest_AccountRequest_StorageRequest.encode(
          v!,
          writer.uint32(18).fork()
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): AccountProofsRequest_AccountRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseAccountProofsRequest_AccountRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.accountId = AccountId.decode(reader, reader.uint32());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.storageRequests.push(
              AccountProofsRequest_AccountRequest_StorageRequest.decode(
                reader,
                reader.uint32()
              )
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): AccountProofsRequest_AccountRequest {
      return {
        accountId: isSet(object.accountId)
          ? AccountId.fromJSON(object.accountId)
          : undefined,
        storageRequests: globalThis.Array.isArray(object?.storageRequests)
          ? object.storageRequests.map((e: any) =>
              AccountProofsRequest_AccountRequest_StorageRequest.fromJSON(e)
            )
          : [],
      };
    },

    toJSON(message: AccountProofsRequest_AccountRequest): unknown {
      const obj: any = {};
      if (message.accountId !== undefined) {
        obj.accountId = AccountId.toJSON(message.accountId);
      }
      if (message.storageRequests?.length) {
        obj.storageRequests = message.storageRequests.map((e) =>
          AccountProofsRequest_AccountRequest_StorageRequest.toJSON(e)
        );
      }
      return obj;
    },

    create<
      I extends Exact<DeepPartial<AccountProofsRequest_AccountRequest>, I>
    >(base?: I): AccountProofsRequest_AccountRequest {
      return AccountProofsRequest_AccountRequest.fromPartial(
        base ?? ({} as any)
      );
    },
    fromPartial<
      I extends Exact<DeepPartial<AccountProofsRequest_AccountRequest>, I>
    >(object: I): AccountProofsRequest_AccountRequest {
      const message = createBaseAccountProofsRequest_AccountRequest();
      message.accountId =
        object.accountId !== undefined && object.accountId !== null
          ? AccountId.fromPartial(object.accountId)
          : undefined;
      message.storageRequests =
        object.storageRequests?.map((e) =>
          AccountProofsRequest_AccountRequest_StorageRequest.fromPartial(e)
        ) || [];
      return message;
    },
  };

function createBaseAccountProofsRequest_AccountRequest_StorageRequest(): AccountProofsRequest_AccountRequest_StorageRequest {
  return { storageSlotIndex: 0, mapKeys: [] };
}

export const AccountProofsRequest_AccountRequest_StorageRequest: MessageFns<AccountProofsRequest_AccountRequest_StorageRequest> =
  {
    encode(
      message: AccountProofsRequest_AccountRequest_StorageRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.storageSlotIndex !== 0) {
        writer.uint32(8).uint32(message.storageSlotIndex);
      }
      for (const v of message.mapKeys) {
        Digest.encode(v!, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): AccountProofsRequest_AccountRequest_StorageRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseAccountProofsRequest_AccountRequest_StorageRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.storageSlotIndex = reader.uint32();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.mapKeys.push(Digest.decode(reader, reader.uint32()));
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): AccountProofsRequest_AccountRequest_StorageRequest {
      return {
        storageSlotIndex: isSet(object.storageSlotIndex)
          ? globalThis.Number(object.storageSlotIndex)
          : 0,
        mapKeys: globalThis.Array.isArray(object?.mapKeys)
          ? object.mapKeys.map((e: any) => Digest.fromJSON(e))
          : [],
      };
    },

    toJSON(
      message: AccountProofsRequest_AccountRequest_StorageRequest
    ): unknown {
      const obj: any = {};
      if (message.storageSlotIndex !== 0) {
        obj.storageSlotIndex = Math.round(message.storageSlotIndex);
      }
      if (message.mapKeys?.length) {
        obj.mapKeys = message.mapKeys.map((e) => Digest.toJSON(e));
      }
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<AccountProofsRequest_AccountRequest_StorageRequest>,
        I
      >
    >(base?: I): AccountProofsRequest_AccountRequest_StorageRequest {
      return AccountProofsRequest_AccountRequest_StorageRequest.fromPartial(
        base ?? ({} as any)
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<AccountProofsRequest_AccountRequest_StorageRequest>,
        I
      >
    >(object: I): AccountProofsRequest_AccountRequest_StorageRequest {
      const message =
        createBaseAccountProofsRequest_AccountRequest_StorageRequest();
      message.storageSlotIndex = object.storageSlotIndex ?? 0;
      message.mapKeys = object.mapKeys?.map((e) => Digest.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseAccountProofs(): AccountProofs {
  return { blockNum: 0, accountProofs: [] };
}

export const AccountProofs: MessageFns<AccountProofs> = {
  encode(
    message: AccountProofs,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.blockNum !== 0) {
      writer.uint32(13).fixed32(message.blockNum);
    }
    for (const v of message.accountProofs) {
      AccountProofs_AccountProof.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountProofs {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountProofs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.blockNum = reader.fixed32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountProofs.push(
            AccountProofs_AccountProof.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountProofs {
    return {
      blockNum: isSet(object.blockNum) ? globalThis.Number(object.blockNum) : 0,
      accountProofs: globalThis.Array.isArray(object?.accountProofs)
        ? object.accountProofs.map((e: any) =>
            AccountProofs_AccountProof.fromJSON(e)
          )
        : [],
    };
  },

  toJSON(message: AccountProofs): unknown {
    const obj: any = {};
    if (message.blockNum !== 0) {
      obj.blockNum = Math.round(message.blockNum);
    }
    if (message.accountProofs?.length) {
      obj.accountProofs = message.accountProofs.map((e) =>
        AccountProofs_AccountProof.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountProofs>, I>>(
    base?: I
  ): AccountProofs {
    return AccountProofs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountProofs>, I>>(
    object: I
  ): AccountProofs {
    const message = createBaseAccountProofs();
    message.blockNum = object.blockNum ?? 0;
    message.accountProofs =
      object.accountProofs?.map((e) =>
        AccountProofs_AccountProof.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseAccountProofs_AccountProof(): AccountProofs_AccountProof {
  return { witness: undefined, stateHeader: undefined };
}

export const AccountProofs_AccountProof: MessageFns<AccountProofs_AccountProof> =
  {
    encode(
      message: AccountProofs_AccountProof,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.witness !== undefined) {
        AccountWitness.encode(message.witness, writer.uint32(10).fork()).join();
      }
      if (message.stateHeader !== undefined) {
        AccountProofs_AccountProof_AccountStateHeader.encode(
          message.stateHeader,
          writer.uint32(18).fork()
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): AccountProofs_AccountProof {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseAccountProofs_AccountProof();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.witness = AccountWitness.decode(reader, reader.uint32());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.stateHeader =
              AccountProofs_AccountProof_AccountStateHeader.decode(
                reader,
                reader.uint32()
              );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): AccountProofs_AccountProof {
      return {
        witness: isSet(object.witness)
          ? AccountWitness.fromJSON(object.witness)
          : undefined,
        stateHeader: isSet(object.stateHeader)
          ? AccountProofs_AccountProof_AccountStateHeader.fromJSON(
              object.stateHeader
            )
          : undefined,
      };
    },

    toJSON(message: AccountProofs_AccountProof): unknown {
      const obj: any = {};
      if (message.witness !== undefined) {
        obj.witness = AccountWitness.toJSON(message.witness);
      }
      if (message.stateHeader !== undefined) {
        obj.stateHeader = AccountProofs_AccountProof_AccountStateHeader.toJSON(
          message.stateHeader
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<AccountProofs_AccountProof>, I>>(
      base?: I
    ): AccountProofs_AccountProof {
      return AccountProofs_AccountProof.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<AccountProofs_AccountProof>, I>>(
      object: I
    ): AccountProofs_AccountProof {
      const message = createBaseAccountProofs_AccountProof();
      message.witness =
        object.witness !== undefined && object.witness !== null
          ? AccountWitness.fromPartial(object.witness)
          : undefined;
      message.stateHeader =
        object.stateHeader !== undefined && object.stateHeader !== null
          ? AccountProofs_AccountProof_AccountStateHeader.fromPartial(
              object.stateHeader
            )
          : undefined;
      return message;
    },
  };

function createBaseAccountProofs_AccountProof_AccountStateHeader(): AccountProofs_AccountProof_AccountStateHeader {
  return {
    header: undefined,
    storageHeader: new Uint8Array(0),
    accountCode: undefined,
    storageMaps: [],
  };
}

export const AccountProofs_AccountProof_AccountStateHeader: MessageFns<AccountProofs_AccountProof_AccountStateHeader> =
  {
    encode(
      message: AccountProofs_AccountProof_AccountStateHeader,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.header !== undefined) {
        AccountHeader.encode(message.header, writer.uint32(10).fork()).join();
      }
      if (message.storageHeader.length !== 0) {
        writer.uint32(18).bytes(message.storageHeader);
      }
      if (message.accountCode !== undefined) {
        writer.uint32(26).bytes(message.accountCode);
      }
      for (const v of message.storageMaps) {
        AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof.encode(
          v!,
          writer.uint32(34).fork()
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): AccountProofs_AccountProof_AccountStateHeader {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseAccountProofs_AccountProof_AccountStateHeader();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.header = AccountHeader.decode(reader, reader.uint32());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.storageHeader = reader.bytes();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.accountCode = reader.bytes();
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.storageMaps.push(
              AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof.decode(
                reader,
                reader.uint32()
              )
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): AccountProofs_AccountProof_AccountStateHeader {
      return {
        header: isSet(object.header)
          ? AccountHeader.fromJSON(object.header)
          : undefined,
        storageHeader: isSet(object.storageHeader)
          ? bytesFromBase64(object.storageHeader)
          : new Uint8Array(0),
        accountCode: isSet(object.accountCode)
          ? bytesFromBase64(object.accountCode)
          : undefined,
        storageMaps: globalThis.Array.isArray(object?.storageMaps)
          ? object.storageMaps.map((e: any) =>
              AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof.fromJSON(
                e
              )
            )
          : [],
      };
    },

    toJSON(message: AccountProofs_AccountProof_AccountStateHeader): unknown {
      const obj: any = {};
      if (message.header !== undefined) {
        obj.header = AccountHeader.toJSON(message.header);
      }
      if (message.storageHeader.length !== 0) {
        obj.storageHeader = base64FromBytes(message.storageHeader);
      }
      if (message.accountCode !== undefined) {
        obj.accountCode = base64FromBytes(message.accountCode);
      }
      if (message.storageMaps?.length) {
        obj.storageMaps = message.storageMaps.map((e) =>
          AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof.toJSON(
            e
          )
        );
      }
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<AccountProofs_AccountProof_AccountStateHeader>,
        I
      >
    >(base?: I): AccountProofs_AccountProof_AccountStateHeader {
      return AccountProofs_AccountProof_AccountStateHeader.fromPartial(
        base ?? ({} as any)
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<AccountProofs_AccountProof_AccountStateHeader>,
        I
      >
    >(object: I): AccountProofs_AccountProof_AccountStateHeader {
      const message = createBaseAccountProofs_AccountProof_AccountStateHeader();
      message.header =
        object.header !== undefined && object.header !== null
          ? AccountHeader.fromPartial(object.header)
          : undefined;
      message.storageHeader = object.storageHeader ?? new Uint8Array(0);
      message.accountCode = object.accountCode ?? undefined;
      message.storageMaps =
        object.storageMaps?.map((e) =>
          AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof.fromPartial(
            e
          )
        ) || [];
      return message;
    },
  };

function createBaseAccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof(): AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof {
  return { storageSlot: 0, smtProof: new Uint8Array(0) };
}

export const AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof: MessageFns<AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof> =
  {
    encode(
      message: AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.storageSlot !== 0) {
        writer.uint32(8).uint32(message.storageSlot);
      }
      if (message.smtProof.length !== 0) {
        writer.uint32(18).bytes(message.smtProof);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseAccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.storageSlot = reader.uint32();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.smtProof = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(
      object: any
    ): AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof {
      return {
        storageSlot: isSet(object.storageSlot)
          ? globalThis.Number(object.storageSlot)
          : 0,
        smtProof: isSet(object.smtProof)
          ? bytesFromBase64(object.smtProof)
          : new Uint8Array(0),
      };
    },

    toJSON(
      message: AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof
    ): unknown {
      const obj: any = {};
      if (message.storageSlot !== 0) {
        obj.storageSlot = Math.round(message.storageSlot);
      }
      if (message.smtProof.length !== 0) {
        obj.smtProof = base64FromBytes(message.smtProof);
      }
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof>,
        I
      >
    >(
      base?: I
    ): AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof {
      return AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof.fromPartial(
        base ?? ({} as any)
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof>,
        I
      >
    >(
      object: I
    ): AccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof {
      const message =
        createBaseAccountProofs_AccountProof_AccountStateHeader_StorageSlotMapProof();
      message.storageSlot = object.storageSlot ?? 0;
      message.smtProof = object.smtProof ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseAccountStateDeltaRequest(): AccountStateDeltaRequest {
  return { accountId: undefined, fromBlockNum: 0, toBlockNum: 0 };
}

export const AccountStateDeltaRequest: MessageFns<AccountStateDeltaRequest> = {
  encode(
    message: AccountStateDeltaRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.accountId !== undefined) {
      AccountId.encode(message.accountId, writer.uint32(10).fork()).join();
    }
    if (message.fromBlockNum !== 0) {
      writer.uint32(21).fixed32(message.fromBlockNum);
    }
    if (message.toBlockNum !== 0) {
      writer.uint32(29).fixed32(message.toBlockNum);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): AccountStateDeltaRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountStateDeltaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = AccountId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.fromBlockNum = reader.fixed32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.toBlockNum = reader.fixed32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountStateDeltaRequest {
    return {
      accountId: isSet(object.accountId)
        ? AccountId.fromJSON(object.accountId)
        : undefined,
      fromBlockNum: isSet(object.fromBlockNum)
        ? globalThis.Number(object.fromBlockNum)
        : 0,
      toBlockNum: isSet(object.toBlockNum)
        ? globalThis.Number(object.toBlockNum)
        : 0,
    };
  },

  toJSON(message: AccountStateDeltaRequest): unknown {
    const obj: any = {};
    if (message.accountId !== undefined) {
      obj.accountId = AccountId.toJSON(message.accountId);
    }
    if (message.fromBlockNum !== 0) {
      obj.fromBlockNum = Math.round(message.fromBlockNum);
    }
    if (message.toBlockNum !== 0) {
      obj.toBlockNum = Math.round(message.toBlockNum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountStateDeltaRequest>, I>>(
    base?: I
  ): AccountStateDeltaRequest {
    return AccountStateDeltaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountStateDeltaRequest>, I>>(
    object: I
  ): AccountStateDeltaRequest {
    const message = createBaseAccountStateDeltaRequest();
    message.accountId =
      object.accountId !== undefined && object.accountId !== null
        ? AccountId.fromPartial(object.accountId)
        : undefined;
    message.fromBlockNum = object.fromBlockNum ?? 0;
    message.toBlockNum = object.toBlockNum ?? 0;
    return message;
  },
};

function createBaseAccountStateDelta(): AccountStateDelta {
  return { delta: undefined };
}

export const AccountStateDelta: MessageFns<AccountStateDelta> = {
  encode(
    message: AccountStateDelta,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.delta !== undefined) {
      writer.uint32(10).bytes(message.delta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountStateDelta {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountStateDelta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delta = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountStateDelta {
    return {
      delta: isSet(object.delta) ? bytesFromBase64(object.delta) : undefined,
    };
  },

  toJSON(message: AccountStateDelta): unknown {
    const obj: any = {};
    if (message.delta !== undefined) {
      obj.delta = base64FromBytes(message.delta);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountStateDelta>, I>>(
    base?: I
  ): AccountStateDelta {
    return AccountStateDelta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountStateDelta>, I>>(
    object: I
  ): AccountStateDelta {
    const message = createBaseAccountStateDelta();
    message.delta = object.delta ?? undefined;
    return message;
  },
};

function createBaseCheckNullifiersByPrefixRequest(): CheckNullifiersByPrefixRequest {
  return { prefixLen: 0, nullifiers: [], blockNum: 0 };
}

export const CheckNullifiersByPrefixRequest: MessageFns<CheckNullifiersByPrefixRequest> =
  {
    encode(
      message: CheckNullifiersByPrefixRequest,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.prefixLen !== 0) {
        writer.uint32(8).uint32(message.prefixLen);
      }
      writer.uint32(18).fork();
      for (const v of message.nullifiers) {
        writer.uint32(v);
      }
      writer.join();
      if (message.blockNum !== 0) {
        writer.uint32(29).fixed32(message.blockNum);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): CheckNullifiersByPrefixRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCheckNullifiersByPrefixRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.prefixLen = reader.uint32();
            continue;
          }
          case 2: {
            if (tag === 16) {
              message.nullifiers.push(reader.uint32());

              continue;
            }

            if (tag === 18) {
              const end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) {
                message.nullifiers.push(reader.uint32());
              }

              continue;
            }

            break;
          }
          case 3: {
            if (tag !== 29) {
              break;
            }

            message.blockNum = reader.fixed32();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CheckNullifiersByPrefixRequest {
      return {
        prefixLen: isSet(object.prefixLen)
          ? globalThis.Number(object.prefixLen)
          : 0,
        nullifiers: globalThis.Array.isArray(object?.nullifiers)
          ? object.nullifiers.map((e: any) => globalThis.Number(e))
          : [],
        blockNum: isSet(object.blockNum)
          ? globalThis.Number(object.blockNum)
          : 0,
      };
    },

    toJSON(message: CheckNullifiersByPrefixRequest): unknown {
      const obj: any = {};
      if (message.prefixLen !== 0) {
        obj.prefixLen = Math.round(message.prefixLen);
      }
      if (message.nullifiers?.length) {
        obj.nullifiers = message.nullifiers.map((e) => Math.round(e));
      }
      if (message.blockNum !== 0) {
        obj.blockNum = Math.round(message.blockNum);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<CheckNullifiersByPrefixRequest>, I>>(
      base?: I
    ): CheckNullifiersByPrefixRequest {
      return CheckNullifiersByPrefixRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<CheckNullifiersByPrefixRequest>, I>
    >(object: I): CheckNullifiersByPrefixRequest {
      const message = createBaseCheckNullifiersByPrefixRequest();
      message.prefixLen = object.prefixLen ?? 0;
      message.nullifiers = object.nullifiers?.map((e) => e) || [];
      message.blockNum = object.blockNum ?? 0;
      return message;
    },
  };

function createBaseCheckNullifiersByPrefixResponse(): CheckNullifiersByPrefixResponse {
  return { nullifiers: [] };
}

export const CheckNullifiersByPrefixResponse: MessageFns<CheckNullifiersByPrefixResponse> =
  {
    encode(
      message: CheckNullifiersByPrefixResponse,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      for (const v of message.nullifiers) {
        CheckNullifiersByPrefixResponse_NullifierUpdate.encode(
          v!,
          writer.uint32(10).fork()
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): CheckNullifiersByPrefixResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCheckNullifiersByPrefixResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.nullifiers.push(
              CheckNullifiersByPrefixResponse_NullifierUpdate.decode(
                reader,
                reader.uint32()
              )
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CheckNullifiersByPrefixResponse {
      return {
        nullifiers: globalThis.Array.isArray(object?.nullifiers)
          ? object.nullifiers.map((e: any) =>
              CheckNullifiersByPrefixResponse_NullifierUpdate.fromJSON(e)
            )
          : [],
      };
    },

    toJSON(message: CheckNullifiersByPrefixResponse): unknown {
      const obj: any = {};
      if (message.nullifiers?.length) {
        obj.nullifiers = message.nullifiers.map((e) =>
          CheckNullifiersByPrefixResponse_NullifierUpdate.toJSON(e)
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<CheckNullifiersByPrefixResponse>, I>>(
      base?: I
    ): CheckNullifiersByPrefixResponse {
      return CheckNullifiersByPrefixResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<CheckNullifiersByPrefixResponse>, I>
    >(object: I): CheckNullifiersByPrefixResponse {
      const message = createBaseCheckNullifiersByPrefixResponse();
      message.nullifiers =
        object.nullifiers?.map((e) =>
          CheckNullifiersByPrefixResponse_NullifierUpdate.fromPartial(e)
        ) || [];
      return message;
    },
  };

function createBaseCheckNullifiersByPrefixResponse_NullifierUpdate(): CheckNullifiersByPrefixResponse_NullifierUpdate {
  return { nullifier: undefined, blockNum: 0 };
}

export const CheckNullifiersByPrefixResponse_NullifierUpdate: MessageFns<CheckNullifiersByPrefixResponse_NullifierUpdate> =
  {
    encode(
      message: CheckNullifiersByPrefixResponse_NullifierUpdate,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.nullifier !== undefined) {
        Digest.encode(message.nullifier, writer.uint32(10).fork()).join();
      }
      if (message.blockNum !== 0) {
        writer.uint32(21).fixed32(message.blockNum);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): CheckNullifiersByPrefixResponse_NullifierUpdate {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseCheckNullifiersByPrefixResponse_NullifierUpdate();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.nullifier = Digest.decode(reader, reader.uint32());
            continue;
          }
          case 2: {
            if (tag !== 21) {
              break;
            }

            message.blockNum = reader.fixed32();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CheckNullifiersByPrefixResponse_NullifierUpdate {
      return {
        nullifier: isSet(object.nullifier)
          ? Digest.fromJSON(object.nullifier)
          : undefined,
        blockNum: isSet(object.blockNum)
          ? globalThis.Number(object.blockNum)
          : 0,
      };
    },

    toJSON(message: CheckNullifiersByPrefixResponse_NullifierUpdate): unknown {
      const obj: any = {};
      if (message.nullifier !== undefined) {
        obj.nullifier = Digest.toJSON(message.nullifier);
      }
      if (message.blockNum !== 0) {
        obj.blockNum = Math.round(message.blockNum);
      }
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<CheckNullifiersByPrefixResponse_NullifierUpdate>,
        I
      >
    >(base?: I): CheckNullifiersByPrefixResponse_NullifierUpdate {
      return CheckNullifiersByPrefixResponse_NullifierUpdate.fromPartial(
        base ?? ({} as any)
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<CheckNullifiersByPrefixResponse_NullifierUpdate>,
        I
      >
    >(object: I): CheckNullifiersByPrefixResponse_NullifierUpdate {
      const message =
        createBaseCheckNullifiersByPrefixResponse_NullifierUpdate();
      message.nullifier =
        object.nullifier !== undefined && object.nullifier !== null
          ? Digest.fromPartial(object.nullifier)
          : undefined;
      message.blockNum = object.blockNum ?? 0;
      return message;
    },
  };

function createBaseNullifierList(): NullifierList {
  return { nullifiers: [] };
}

export const NullifierList: MessageFns<NullifierList> = {
  encode(
    message: NullifierList,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.nullifiers) {
      Digest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NullifierList {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNullifierList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nullifiers.push(Digest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NullifierList {
    return {
      nullifiers: globalThis.Array.isArray(object?.nullifiers)
        ? object.nullifiers.map((e: any) => Digest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NullifierList): unknown {
    const obj: any = {};
    if (message.nullifiers?.length) {
      obj.nullifiers = message.nullifiers.map((e) => Digest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NullifierList>, I>>(
    base?: I
  ): NullifierList {
    return NullifierList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NullifierList>, I>>(
    object: I
  ): NullifierList {
    const message = createBaseNullifierList();
    message.nullifiers =
      object.nullifiers?.map((e) => Digest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCheckNullifiersResponse(): CheckNullifiersResponse {
  return { proofs: [] };
}

export const CheckNullifiersResponse: MessageFns<CheckNullifiersResponse> = {
  encode(
    message: CheckNullifiersResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.proofs) {
      SmtOpening.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): CheckNullifiersResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckNullifiersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proofs.push(SmtOpening.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckNullifiersResponse {
    return {
      proofs: globalThis.Array.isArray(object?.proofs)
        ? object.proofs.map((e: any) => SmtOpening.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CheckNullifiersResponse): unknown {
    const obj: any = {};
    if (message.proofs?.length) {
      obj.proofs = message.proofs.map((e) => SmtOpening.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckNullifiersResponse>, I>>(
    base?: I
  ): CheckNullifiersResponse {
    return CheckNullifiersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckNullifiersResponse>, I>>(
    object: I
  ): CheckNullifiersResponse {
    const message = createBaseCheckNullifiersResponse();
    message.proofs = object.proofs?.map((e) => SmtOpening.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSyncStateRequest(): SyncStateRequest {
  return { blockNum: 0, accountIds: [], noteTags: [] };
}

export const SyncStateRequest: MessageFns<SyncStateRequest> = {
  encode(
    message: SyncStateRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.blockNum !== 0) {
      writer.uint32(13).fixed32(message.blockNum);
    }
    for (const v of message.accountIds) {
      AccountId.encode(v!, writer.uint32(18).fork()).join();
    }
    writer.uint32(26).fork();
    for (const v of message.noteTags) {
      writer.fixed32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncStateRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.blockNum = reader.fixed32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountIds.push(AccountId.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag === 29) {
            message.noteTags.push(reader.fixed32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.noteTags.push(reader.fixed32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncStateRequest {
    return {
      blockNum: isSet(object.blockNum) ? globalThis.Number(object.blockNum) : 0,
      accountIds: globalThis.Array.isArray(object?.accountIds)
        ? object.accountIds.map((e: any) => AccountId.fromJSON(e))
        : [],
      noteTags: globalThis.Array.isArray(object?.noteTags)
        ? object.noteTags.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: SyncStateRequest): unknown {
    const obj: any = {};
    if (message.blockNum !== 0) {
      obj.blockNum = Math.round(message.blockNum);
    }
    if (message.accountIds?.length) {
      obj.accountIds = message.accountIds.map((e) => AccountId.toJSON(e));
    }
    if (message.noteTags?.length) {
      obj.noteTags = message.noteTags.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncStateRequest>, I>>(
    base?: I
  ): SyncStateRequest {
    return SyncStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncStateRequest>, I>>(
    object: I
  ): SyncStateRequest {
    const message = createBaseSyncStateRequest();
    message.blockNum = object.blockNum ?? 0;
    message.accountIds =
      object.accountIds?.map((e) => AccountId.fromPartial(e)) || [];
    message.noteTags = object.noteTags?.map((e) => e) || [];
    return message;
  },
};

function createBaseSyncStateResponse(): SyncStateResponse {
  return {
    chainTip: 0,
    blockHeader: undefined,
    mmrDelta: undefined,
    accounts: [],
    transactions: [],
    notes: [],
  };
}

export const SyncStateResponse: MessageFns<SyncStateResponse> = {
  encode(
    message: SyncStateResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.chainTip !== 0) {
      writer.uint32(13).fixed32(message.chainTip);
    }
    if (message.blockHeader !== undefined) {
      BlockHeader.encode(message.blockHeader, writer.uint32(18).fork()).join();
    }
    if (message.mmrDelta !== undefined) {
      MmrDelta.encode(message.mmrDelta, writer.uint32(26).fork()).join();
    }
    for (const v of message.accounts) {
      AccountSummary.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.transactions) {
      TransactionSummary.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.notes) {
      NoteSyncRecord.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncStateResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.chainTip = reader.fixed32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blockHeader = BlockHeader.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mmrDelta = MmrDelta.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.accounts.push(AccountSummary.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.transactions.push(
            TransactionSummary.decode(reader, reader.uint32())
          );
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.notes.push(NoteSyncRecord.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncStateResponse {
    return {
      chainTip: isSet(object.chainTip) ? globalThis.Number(object.chainTip) : 0,
      blockHeader: isSet(object.blockHeader)
        ? BlockHeader.fromJSON(object.blockHeader)
        : undefined,
      mmrDelta: isSet(object.mmrDelta)
        ? MmrDelta.fromJSON(object.mmrDelta)
        : undefined,
      accounts: globalThis.Array.isArray(object?.accounts)
        ? object.accounts.map((e: any) => AccountSummary.fromJSON(e))
        : [],
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TransactionSummary.fromJSON(e))
        : [],
      notes: globalThis.Array.isArray(object?.notes)
        ? object.notes.map((e: any) => NoteSyncRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SyncStateResponse): unknown {
    const obj: any = {};
    if (message.chainTip !== 0) {
      obj.chainTip = Math.round(message.chainTip);
    }
    if (message.blockHeader !== undefined) {
      obj.blockHeader = BlockHeader.toJSON(message.blockHeader);
    }
    if (message.mmrDelta !== undefined) {
      obj.mmrDelta = MmrDelta.toJSON(message.mmrDelta);
    }
    if (message.accounts?.length) {
      obj.accounts = message.accounts.map((e) => AccountSummary.toJSON(e));
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) =>
        TransactionSummary.toJSON(e)
      );
    }
    if (message.notes?.length) {
      obj.notes = message.notes.map((e) => NoteSyncRecord.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncStateResponse>, I>>(
    base?: I
  ): SyncStateResponse {
    return SyncStateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncStateResponse>, I>>(
    object: I
  ): SyncStateResponse {
    const message = createBaseSyncStateResponse();
    message.chainTip = object.chainTip ?? 0;
    message.blockHeader =
      object.blockHeader !== undefined && object.blockHeader !== null
        ? BlockHeader.fromPartial(object.blockHeader)
        : undefined;
    message.mmrDelta =
      object.mmrDelta !== undefined && object.mmrDelta !== null
        ? MmrDelta.fromPartial(object.mmrDelta)
        : undefined;
    message.accounts =
      object.accounts?.map((e) => AccountSummary.fromPartial(e)) || [];
    message.transactions =
      object.transactions?.map((e) => TransactionSummary.fromPartial(e)) || [];
    message.notes =
      object.notes?.map((e) => NoteSyncRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSyncNotesRequest(): SyncNotesRequest {
  return { blockNum: 0, noteTags: [] };
}

export const SyncNotesRequest: MessageFns<SyncNotesRequest> = {
  encode(
    message: SyncNotesRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.blockNum !== 0) {
      writer.uint32(13).fixed32(message.blockNum);
    }
    writer.uint32(18).fork();
    for (const v of message.noteTags) {
      writer.fixed32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncNotesRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncNotesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.blockNum = reader.fixed32();
          continue;
        }
        case 2: {
          if (tag === 21) {
            message.noteTags.push(reader.fixed32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.noteTags.push(reader.fixed32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncNotesRequest {
    return {
      blockNum: isSet(object.blockNum) ? globalThis.Number(object.blockNum) : 0,
      noteTags: globalThis.Array.isArray(object?.noteTags)
        ? object.noteTags.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: SyncNotesRequest): unknown {
    const obj: any = {};
    if (message.blockNum !== 0) {
      obj.blockNum = Math.round(message.blockNum);
    }
    if (message.noteTags?.length) {
      obj.noteTags = message.noteTags.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncNotesRequest>, I>>(
    base?: I
  ): SyncNotesRequest {
    return SyncNotesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncNotesRequest>, I>>(
    object: I
  ): SyncNotesRequest {
    const message = createBaseSyncNotesRequest();
    message.blockNum = object.blockNum ?? 0;
    message.noteTags = object.noteTags?.map((e) => e) || [];
    return message;
  },
};

function createBaseSyncNotesResponse(): SyncNotesResponse {
  return { chainTip: 0, blockHeader: undefined, mmrPath: undefined, notes: [] };
}

export const SyncNotesResponse: MessageFns<SyncNotesResponse> = {
  encode(
    message: SyncNotesResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.chainTip !== 0) {
      writer.uint32(13).fixed32(message.chainTip);
    }
    if (message.blockHeader !== undefined) {
      BlockHeader.encode(message.blockHeader, writer.uint32(18).fork()).join();
    }
    if (message.mmrPath !== undefined) {
      MerklePath.encode(message.mmrPath, writer.uint32(26).fork()).join();
    }
    for (const v of message.notes) {
      NoteSyncRecord.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncNotesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncNotesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.chainTip = reader.fixed32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blockHeader = BlockHeader.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mmrPath = MerklePath.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.notes.push(NoteSyncRecord.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncNotesResponse {
    return {
      chainTip: isSet(object.chainTip) ? globalThis.Number(object.chainTip) : 0,
      blockHeader: isSet(object.blockHeader)
        ? BlockHeader.fromJSON(object.blockHeader)
        : undefined,
      mmrPath: isSet(object.mmrPath)
        ? MerklePath.fromJSON(object.mmrPath)
        : undefined,
      notes: globalThis.Array.isArray(object?.notes)
        ? object.notes.map((e: any) => NoteSyncRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SyncNotesResponse): unknown {
    const obj: any = {};
    if (message.chainTip !== 0) {
      obj.chainTip = Math.round(message.chainTip);
    }
    if (message.blockHeader !== undefined) {
      obj.blockHeader = BlockHeader.toJSON(message.blockHeader);
    }
    if (message.mmrPath !== undefined) {
      obj.mmrPath = MerklePath.toJSON(message.mmrPath);
    }
    if (message.notes?.length) {
      obj.notes = message.notes.map((e) => NoteSyncRecord.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncNotesResponse>, I>>(
    base?: I
  ): SyncNotesResponse {
    return SyncNotesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncNotesResponse>, I>>(
    object: I
  ): SyncNotesResponse {
    const message = createBaseSyncNotesResponse();
    message.chainTip = object.chainTip ?? 0;
    message.blockHeader =
      object.blockHeader !== undefined && object.blockHeader !== null
        ? BlockHeader.fromPartial(object.blockHeader)
        : undefined;
    message.mmrPath =
      object.mmrPath !== undefined && object.mmrPath !== null
        ? MerklePath.fromPartial(object.mmrPath)
        : undefined;
    message.notes =
      object.notes?.map((e) => NoteSyncRecord.fromPartial(e)) || [];
    return message;
  },
};

/** Store API for the RPC component */
export interface Rpc {
  /** Returns the status info. */
  Status(request: Empty): Promise<StoreStatus>;
  /** Returns a nullifier proof for each of the requested nullifiers. */
  CheckNullifiers(request: NullifierList): Promise<CheckNullifiersResponse>;
  /**
   * Returns a list of nullifiers that match the specified prefixes and are recorded in the node.
   *
   * Note that only 16-bit prefixes are supported at this time.
   */
  CheckNullifiersByPrefix(
    request: CheckNullifiersByPrefixRequest
  ): Promise<CheckNullifiersByPrefixResponse>;
  /** Returns the latest state of an account with the specified ID. */
  GetAccountDetails(request: AccountId): Promise<AccountDetails>;
  /** Returns the latest state proofs of the specified accounts. */
  GetAccountProofs(request: AccountProofsRequest): Promise<AccountProofs>;
  /**
   * Returns delta of the account states in the range from `from_block_num` (exclusive) to
   * `to_block_num` (inclusive).
   */
  GetAccountStateDelta(
    request: AccountStateDeltaRequest
  ): Promise<AccountStateDelta>;
  /** Returns raw block data for the specified block number. */
  GetBlockByNumber(request: BlockNumber): Promise<MaybeBlock>;
  /**
   * Retrieves block header by given block number. Optionally, it also returns the MMR path
   * and current chain length to authenticate the block's inclusion.
   */
  GetBlockHeaderByNumber(
    request: BlockHeaderByNumberRequest
  ): Promise<BlockHeaderByNumberResponse>;
  /** Returns a list of committed notes matching the provided note IDs. */
  GetNotesById(request: NoteIdList): Promise<CommittedNoteList>;
  /**
   * Returns info which can be used by the client to sync up to the tip of chain for the notes they are interested in.
   *
   * Client specifies the `note_tags` they are interested in, and the block height from which to search for new for
   * matching notes for. The request will then return the next block containing any note matching the provided tags.
   *
   * The response includes each note's metadata and inclusion proof.
   *
   * A basic note sync can be implemented by repeatedly requesting the previous response's block until reaching the
   * tip of the chain.
   */
  SyncNotes(request: SyncNotesRequest): Promise<SyncNotesResponse>;
  /**
   * Returns info which can be used by the client to sync up to the latest state of the chain
   * for the objects (accounts, notes, nullifiers) the client is interested in.
   *
   * This request returns the next block containing requested data. It also returns `chain_tip`
   * which is the latest block number in the chain. Client is expected to repeat these requests
   * in a loop until `response.block_header.block_num == response.chain_tip`, at which point
   * the client is fully synchronized with the chain.
   *
   * Each request also returns info about new notes, nullifiers etc. created. It also returns
   * Chain MMR delta that can be used to update the state of Chain MMR. This includes both chain
   * MMR peaks and chain MMR nodes.
   *
   * For preserving some degree of privacy, note tags and nullifiers filters contain only high
   * part of hashes. Thus, returned data contains excessive notes and nullifiers, client can make
   * additional filtering of that data on its side.
   */
  SyncState(request: SyncStateRequest): Promise<SyncStateResponse>;
}

export const RpcServiceName = "rpc_store.Rpc";

export class RpcClientImpl implements Rpc {
  private readonly rpc: Rpc;
  private readonly service: string;

  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.rpc = rpc;
    this.service = opts?.service || "rpc.Api";
  }

  // Implementacin requerida por la interface
  request(
    service: string,
    method: string,
    data: Uint8Array
  ): Promise<Uint8Array> {
    return this.rpc.request(service, method, data);
  }

  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || RpcServiceName;
    this.rpc = rpc;
    this.Status = this.Status.bind(this);
    this.CheckNullifiers = this.CheckNullifiers.bind(this);
    this.CheckNullifiersByPrefix = this.CheckNullifiersByPrefix.bind(this);
    this.GetAccountDetails = this.GetAccountDetails.bind(this);
    this.GetAccountProofs = this.GetAccountProofs.bind(this);
    this.GetAccountStateDelta = this.GetAccountStateDelta.bind(this);
    this.GetBlockByNumber = this.GetBlockByNumber.bind(this);
    this.GetBlockHeaderByNumber = this.GetBlockHeaderByNumber.bind(this);
    this.GetNotesById = this.GetNotesById.bind(this);
    this.SyncNotes = this.SyncNotes.bind(this);
    this.SyncState = this.SyncState.bind(this);
  }
  Status(request: Empty): Promise<StoreStatus> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "Status", data);
    return promise.then((data) => StoreStatus.decode(new BinaryReader(data)));
  }

  CheckNullifiers(request: NullifierList): Promise<CheckNullifiersResponse> {
    const data = NullifierList.encode(request).finish();
    const promise = this.rpc.request(this.service, "CheckNullifiers", data);
    return promise.then((data) =>
      CheckNullifiersResponse.decode(new BinaryReader(data))
    );
  }

  CheckNullifiersByPrefix(
    request: CheckNullifiersByPrefixRequest
  ): Promise<CheckNullifiersByPrefixResponse> {
    const data = CheckNullifiersByPrefixRequest.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "CheckNullifiersByPrefix",
      data
    );
    return promise.then((data) =>
      CheckNullifiersByPrefixResponse.decode(new BinaryReader(data))
    );
  }

  GetAccountDetails(request: AccountId): Promise<AccountDetails> {
    const data = AccountId.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAccountDetails", data);
    return promise.then((data) =>
      AccountDetails.decode(new BinaryReader(data))
    );
  }

  GetAccountProofs(request: AccountProofsRequest): Promise<AccountProofs> {
    const data = AccountProofsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAccountProofs", data);
    return promise.then((data) => AccountProofs.decode(new BinaryReader(data)));
  }

  GetAccountStateDelta(
    request: AccountStateDeltaRequest
  ): Promise<AccountStateDelta> {
    const data = AccountStateDeltaRequest.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "GetAccountStateDelta",
      data
    );
    return promise.then((data) =>
      AccountStateDelta.decode(new BinaryReader(data))
    );
  }

  GetBlockByNumber(request: BlockNumber): Promise<MaybeBlock> {
    const data = BlockNumber.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBlockByNumber", data);
    return promise.then((data) => MaybeBlock.decode(new BinaryReader(data)));
  }

  GetBlockHeaderByNumber(
    request: BlockHeaderByNumberRequest
  ): Promise<BlockHeaderByNumberResponse> {
    const data = BlockHeaderByNumberRequest.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "GetBlockHeaderByNumber",
      data
    );
    return promise.then((data) =>
      BlockHeaderByNumberResponse.decode(new BinaryReader(data))
    );
  }

  GetNotesById(request: NoteIdList): Promise<CommittedNoteList> {
    const data = NoteIdList.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNotesById", data);
    return promise.then((data) =>
      CommittedNoteList.decode(new BinaryReader(data))
    );
  }

  SyncNotes(request: SyncNotesRequest): Promise<SyncNotesResponse> {
    const data = SyncNotesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SyncNotes", data);
    return promise.then((data) =>
      SyncNotesResponse.decode(new BinaryReader(data))
    );
  }

  SyncState(request: SyncStateRequest): Promise<SyncStateResponse> {
    const data = SyncStateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SyncState", data);
    return promise.then((data) =>
      SyncStateResponse.decode(new BinaryReader(data))
    );
  }
}

interface Rpc {
  request(
    service: string,
    method: string,
    data: Uint8Array
  ): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
